---
tags:
  - controller
  - middleware
  - entities
  - adapters
  - useCases
  - domain
  - backend
---
---
### ‚ùó Conceptos fundamentales

Cosas que hay que saber: **entities, repositories, domain, useCases, infraestructure, Adapters**

---
#### Entities

Para que algo sea una entidad, tiene que cumplir con requisitos conceptuales.
-  Tener identidad propia, como un **id**, que permanece constante
-  Ese ID representa a la entidad **independientemente de sus atributos**.

üì¶ _Ejemplo:_ 
Un usuario (`User`) puede cambiar de nombre, correo, contrase√±a‚Ä¶ pero sigue siendo el mismo usuario porque su identidad (`userId`) no cambia. Puede ser una clase, un objeto.

-  Debe contener **l√≥gica de negocio** relacionada consigo misma.
-  No es un simple ‚Äúcontenedor de datos‚Äù (como un DTO), sino que **hace cosas**, con sentido para su contexto.

üì¶ _Ejemplo:_  
```ts
class Order {
  constructor(public id: string, public total: number, public paid: boolean = false) {}

  pay() {
    if (this.paid) throw new Error("La orden ya fue pagada");
    this.paid = true;
  }
}
```

- Esta en el centro del dominio
- Las entidades forman parte del **modelo de dominio**: representan cosas "con peso" en el negocio.
-  No son solo datos flotantes. Son el **vocabulario real del problema**.
    

üì¶ _Ejemplo (negocio de reservas):_
- `Reserva`, `Cliente`, `Habitaci√≥n`, `Pago` son entidades.
- `ReservaDTO`, `RequestBody`, `UserModel` no lo son (estos est√°n en otras capas).

 ‚ùå ¬øQu√© NO es una entidad?
- Un simple objeto con datos (`interface`, `DTO`, `request body`)
- Un resultado de c√°lculo puntual
- Una clase que representa l√≥gica de aplicaci√≥n pero **sin estado persistente**

üß† Tip mental:
> **Una entidad representa "algo del mundo real"** dentro de tu negocio.  
> Si tu sistema modela una tienda, tus entidades ser√°n `Product`, `Cart`, `User`, `Order`.

---
#### Repositories

Es una interface que muestra el contrato/estructura, pero no la logica.
Los **repositories solo deber√≠an contener m√©todos p√∫blicos que definen operaciones de acceso a entidades**, y **no deber√≠an tener estado propio ni l√≥gica adicional**, que no est√© relacionada con la persistencia, ni siquiera propiedades.

Los repositorios:
- Expone solo opciones relevantes para el dominio
- Solo m√©todos que **tengan sentido para las entidades del dominio**: buscar, guardar, eliminar, etc.

Ejemplo
```ts
interface ProductRepository {
  findById(id: string): Promise<Product | null>;
  save(product: Product): Promise<void>;
  deleteById(id: string): Promise<void>;
}
```
 
 **Es una interfaz definida en el Dominio**
- El contrato (interfaz) **vive en el dominio**, no en la base de datos ni en infraestructura
- Esto permite cambiar la implementaci√≥n sin tocar casos de uso

üì¶ _Ejemplo:_  
En `/domain/repositories/ProductRepository.ts` defines la interfaz
En `/infrastructure/db/mongo/MongoProductRepository.ts` haces la implementaci√≥n

**No contiene l√≥gica de negocio**
-  Solo **acceso a datos** (consultar, persistir, eliminar).    
-  No deber√≠a validar reglas, aplicar descuentos, ni decidir si algo est√° aprobado.

```ts
// Esto est√° mal: l√≥gica de negocio en repositorio
if (product.stock > 0) { product.applyDiscount(); }
```
 
 **Oculta los detalles de persistencia**

- El c√≥digo que llama al repositorio **no necesita saber si usas Mongo, PostgreSQL, archivos, Redis...**    
- Solo conoce los m√©todos definidos en la interfaz.

```ts
// En un caso de uso
const product = await productRepo.findById("123");
// No importa si por detr√°s usa SQL o JSON plano
```


‚ùå ¬øQu√© **NO** debe hacer un Repository?

| ‚ùå Error com√∫n                          | Por qu√© est√° mal                                                                         |
| -------------------------------------- | ---------------------------------------------------------------------------------------- |
| Usar queries SQL crudas en toda la app | Viola el principio de abstracci√≥n                                                        |
| Tener l√≥gica de negocio                | Debe delegarla al dominio o a los casos de uso                                           |
| Ser dependiente de un framework        | La interfaz no debe importar ni Sequelize, ni Prisma, etc.                               |
| Devolver datos crudos del ORM          | Debe mapear a entidades del dominio (no devolver objetos Mongo o Sequelize directamente) |

---
#### Domain

El coraz√≥n del sistema. Es la carpeta en la est√°n las **entidades** y las **reglas de negocio puras**, sin importar c√≥mo se presentan o almacenan.

**Contiene:**
- **Entidades**: clases con reglas internas.
- **Interfaces de repositorios**: contratos para guardar/cargar entidades (sin implementaci√≥n).
Ejemplo:

/domain
‚îú‚îÄ‚îÄ entities
‚îÇ   ‚îî‚îÄ‚îÄ Product.ts
‚îî‚îÄ‚îÄ repositories
    ‚îî‚îÄ‚îÄ ProductRepository.ts
```ts
//entities/products.ts
export class Product {
  constructor(public id: string, public name: string, public price: number) {}

  applyDiscount(percent: number) {
    this.price -= this.price * (percent / 100);
  }
}
```

```ts
//repositories/productRepository.ts
import { Product } from "../entities/Product";

export interface ProductRepository {
  save(product: Product): Promise<void>;
  findById(id: string): Promise<Product | null>;
}
```

---
#### useCases (casos de uso)
L√≥gica que **usa las entidades para cumplir acciones concretas del sistema**. No sabe nada de frameworks, bases de datos ni UI.

Ejemplo
/src
‚îú‚îÄ‚îÄ application
‚îÇ   ‚îî‚îÄ‚îÄ use_cases
‚îÇ       ‚îî‚îÄ‚îÄ ApplyDiscountUseCase.ts
```ts
//use_cases/applyDiscountUseCase.ts
class ApplyDiscountUseCase {
  constructor(private productRepo: ProductRepository) {}

  async execute(productId: string, discount: number) {
    const product = await this.productRepo.findById(productId);
    if (!product) throw new Error("Producto no encontrado");

    product.applyDiscount(discount);
    await this.productRepo.save(product);
  }
}
```

Donde esta la l√≥gica de findById? -> **ProductRepository.ts** aqui esta la el contrato que dice que se va a hacer, pero no como
**Entonces, donde se hace la l√≥gica?**
La implementaci√≥n concreta se hace en los **adapters**/controllers. Ellos lo importan y los usan a los useCases
Y luego, se pone el controlador en la route, como se hace siempre.

---

#### Infraestructure

 ‚úÖ **Resumen directo:**
- **`infrastructure/` es la carpeta**  
    que **suele contener** la implementaci√≥n concreta de cosas como bases de datos, servicios externos, etc.
- **Los archivos dentro de `infrastructure/` normalmente son los adaptadores**  
    porque est√°n **implementando interfaces del dominio**, usando herramientas del mundo real (Express, Mongo, PostgreSQL, etc.).


üîÅ Ejemplo para fijarlo mejor:
Supongamos que en tu dominio definiste esto:
```ts
import { Product } from ../domain/entities/Product.ts;

// /domain/repositories/ProductRepository.ts
export interface ProductRepository {
  findById(id: string): Promise<Product | null>;
}
```
Ahora vas a implementarlo **usando MongoDB**.
```ts
// /infrastructure/repositories/MongoProductRepository.ts
import { ProductRepository } from "../../domain/repositories/ProductRepository";

export class MongoProductRepository implements ProductRepository {
  async findById(id: string): Promise<Product | null> {
    const doc = await mongo.collection("products").findOne({ _id: id });
    return doc ? new Product(doc._id, doc.name, doc.price) : null;
  }
}
```
Este archivo **MongoProductRepository.ts** es un adaptador, porque:
-  Implementa una interfaz del dominio (`ProductRepository`)
-  Traduce entre el **formato del dominio** y el **formato del mundo real (Mongo)**

Este adaptador **vive dentro de la carpeta `infrastructure/`**, por convenci√≥n y porque depende de herramientas externas.

---
#### Adapters / Controllers

Un adaptador es un archivo que **recibe datos de una capa** (por ejemplo, la base de datos o la API) y los **convierte al formato que otra capa necesita** (como el dominio o el frontend).  
Su trabajo es conectar dos capas que **no se entienden directamente entre s√≠**.

Pero no todos los adaptadores son iguales. Hay **tres tipos principales** en Clean Architecture:

 üü† 1. **Adaptadores de entrada** (Input Adapters)
> Transforman el input del mundo externo en una llamada a un caso de uso.

```ts
// Express (entrada por HTTP)
app.post("/login", async (req, res) => {
  const useCase = new LoginUseCase(...);
  const result = await useCase.execute(req.body);
  res.json(result);
});
```
Este **controller** es un **adaptador de entrada**.

 üîµ 2. **Adaptadores de salida** (Output Adapters)
 > Implementan interfaces del dominio para hablar con sistemas externos (DB, API, etc...)
 
 ```ts
import { User } from "../../domain/entities/User";
import { UserRepository } from "../../domain/repositories/UserRepository.ts"

class MongoUserRepository implements UserRepository {
  async findById(id: string) {
    const doc = await db.collection("users").findOne({ _id: id });
    return new User(doc._id, doc.email); <- 
	//constructor(public id: string, public email: string) {} <- el constructor en       User se veria algo como eso
  }
}
```
Este archivo **es un adaptador de salida**, porque **traduce** entre la **interfaz del dominio** y **MongoDB**.
Aca vemos que findById es el **m√©todo que hace la logica de negocio a hacia la db**, cumpliendo el contrato que pide la interfaz en UserRepository

Los adapters suelen ser llamados controllers, si manejan peticiones http. Ej: userController.ts

 üéØ Regla pr√°ctica para nombrar

| Tipo de archivo               | Sufijo recomendado  | Ubicaci√≥n t√≠pica            |
| ----------------------------- | ------------------- | --------------------------- |
| Controlador HTTP              | `Controller.ts`     | `/interfaces/controllers/`  |
| Repositorio real (DB)         | `Repository.ts`     | `/infrastructure/db/`       |
| Servicio externo (API, email) | `ServiceAdapter.ts` | `/infrastructure/external/` |
| Cliente de API externa        | `Client.ts`         | `/infrastructure/api/`      |

---
### ‚ùì Que hace √∫nica a Clean Arquitecture?

A diferencia de MVC, donde las dependencias a veces se vuelven circulares o van en todas direcciones (especialmente en implementaciones desordenadas), Clean Architecture impone una **regla de oro**:
> **Las dependencias siempre deben apuntar hacia el centro** (hacia el dominio)

Esto significa:
- El dominio no sabe nada de la base de datos, ni de HTTP, ni del framework.
- Pero la base de datos s√≠ conoce el dominio (para guardar sus objetos).
- Igual con los controladores: ellos orquestan casos de uso, pero no contienen sus reglas/l√≥gica de negocio.

‚úÖ **Comparaci√≥n**:
- **MVC**: El modelo a veces llama al controlador o a la vista si no se manejabien.
- **Clean**: El dominio nunca depende de nada. Solo es llamado, nunca llama.
- **Hexagonal**: Tambi√©n sigue este principio, pero Clean lo hace a√∫n m√°s expl√≠cito con capas conc√©ntricas.

#### 1. **Las reglas de negocio est√°n completamente aisladas**

En Clean Architecture, el **n√∫cleo del sistema (Entidades + Casos de uso)** se puede:
- **Testear sin mocks** de base de datos ni de frameworks.
- Ejecutar sin siquiera tener conectada una API real.
    
Esto va m√°s all√° de simplemente tener un "Modelo" en MVC. Clean Architecture diferencia entre:
- **Entidades (negocio puro)**
- **Casos de uso (l√≥gica de aplicaci√≥n)**
- **Interfaces externas (adaptadores)**
    
‚úÖ **Comparaci√≥n**:
- **MVC** mezcla l√≥gicas de negocio en los modelos o incluso en los controladores.
- **Onion** es parecida, pero Clean le da **m√°s flexibilidad a los adaptadores**, permitiendo m√∫ltiples controladores, interfaces web, m√≥viles, etc., hablando con los mismos casos de uso.


#### 2. **La flexibilidad con los adaptadores**

En Clean Architecture, puedes tener
- Varios **drivers de entrada**: API REST, WebSocket, CLI, tareas cron, etc.
- Varios **drivers de salida**: PostgreSQL, MongoDB, S3, colas de mensajes, etc.
    
Todos adaptadores que **conectan** al n√∫cleo mediante interfaces. Esto permite cambiar **implementaciones** sin tocar el core, lo cual es clave en sistemas que cambian con el tiempo.

‚úÖ **Comparaci√≥n**:
- **MVC tradicional** no distingue entre interfaces de entrada/salida. Solo piensa en HTTP.
- **Hexagonal Architecture** (o Ports and Adapters) ya hac√≠a esto, pero Clean lo lleva a un nivel m√°s "completo", unificando mejor las capas.

#### 3. **Estructura conc√©ntrica visual y expl√≠cita**

Mientras que Hexagonal o Onion son parecidas, Clean Architecture se distingue por
- **Visualizar las capas como c√≠rculos** (modelo conc√©ntrico)
- Dar nombres espec√≠ficos: _Entidades_, _Casos de uso_, _Adaptadores_, _Frameworks_
    
Este modelo ayuda a **pensar el dise√±o desde adentro hacia afuera**, algo que no es tan intuitivo en otras arquitecturas.

---
### üß™ Capas de Clean Arquitecture

      +-------------------------+
      |      External Layer     |   ‚Üí Frameworks (React, Express, Flask, DB)
      +-------------------------+
      |    Interface Adapters    |   ‚Üí Controllers, Presenters, Gateways
      +-------------------------+
      |      Application Core    |   ‚Üí Casos de uso (Application/Service Layer)
      +-------------------------+
      |       Domain Layer       |   ‚Üí Entidades (Negocio puro)
      +-------------------------+

 **Descripci√≥n de las capas**:
 
1. **Domain Layer (Entidades)**
    -  Contiene las **reglas de negocio m√°s generales**
    -  No depende de nada externo
    -  Ej: `User`, `Order`, `Product`, etc.
        
2. **Application Layer (useCases / Services)**
    -  L√≥gica de aplicaci√≥n que **usa las entidades**
    -  Orquesta las operaciones del dominio
    -  Ej: `CreateUser`, `ProcessPayment`, etc.
        
3. **Interface Adapters (Controllers / Presenters / Gateways)**
    -  Adaptadores que permiten comunicar el mundo externo con la l√≥gica interna
    -  Ej: `UserController`, `UserRepositoryImpl`
        
4. **Infrastructure / Frameworks (UI, DB, Web)**
    -  Frameworks, tecnolog√≠as concretas
    -  Ej: React, Express, MongoDB, PostgreSQL

---
### üìÅ Estructura de carpetas (Frotend React)
No es la mas com√∫n para react, pero se puede usar en proyectos grandes. La mas usada para react es **Featured-based design**. Tambien se puede mezclar Featured-based con Clean arquitecture para React.
Si quer√©s adaptar Clean Arquitecture sin React, modifica esta estructura para que no use react y se adapte a vanilla js/ts, angular, o necesidades de tu proyecto

```
/src
‚îÇ
‚îú‚îÄ‚îÄ domain/                      # Modelo puro de negocio, sin dependencias
‚îÇ   ‚îú‚îÄ‚îÄ models/         # Interfaces o clases de entidades (User, products, etc...)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ User.ts
‚îÇ   ‚îú‚îÄ‚îÄ valueObjects/          # Objetos de valor (Email, Password)
‚îÇ   ‚îî‚îÄ‚îÄ services/              # L√≥gica de dominio pura (ej. validadores)
‚îÇ
‚îú‚îÄ‚îÄ application/                # Casos de uso de frontend (interacci√≥n usuario)
‚îÇ   ‚îú‚îÄ‚îÄ useCases/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ registerUser.ts
‚îÇ   ‚îî‚îÄ‚îÄ interfaces/            # Interfaces de abstracci√≥n (ej. UserRepository)
‚îÇ       ‚îî‚îÄ‚îÄ IUserRepository.ts
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/        # Implementaciones concretas (fetch, localstorage,etc)
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userApi.ts         # Conexiones HTTP
‚îÇ   ‚îî‚îÄ‚îÄ repositories/
‚îÇ       ‚îî‚îÄ‚îÄ UserRepository.ts  # Implementaci√≥n concreta de IUserRepository
‚îÇ
‚îú‚îÄ‚îÄ presentation/               # UI pura (sin l√≥gica de dominio)
‚îÇ   ‚îú‚îÄ‚îÄ components/            # Botones, inputs, formularios
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserForm.tsx
‚îÇ   ‚îú‚îÄ‚îÄ pages/                 # Vistas completas (una por ruta)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RegisterPage.tsx
‚îÇ   ‚îî‚îÄ‚îÄ hooks/                 # Custom hooks (useRegisterUser, useUser)
‚îÇ
‚îú‚îÄ‚îÄ shared/                     # C√≥digo reutilizable (tipos, helpers, estilos)
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ constants/
‚îÇ
‚îî‚îÄ‚îÄ main.tsx                    # Entry point (render + router + provider)
```

### üìÅ Estructura de carpetas (Backend node)
Muy usado en Backends robustos

```
/src
‚îÇ
‚îú‚îÄ‚îÄ domain/                     # Entidades y l√≥gica de negocio pura
‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ User.ts
‚îÇ   ‚îú‚îÄ‚îÄ valueObjects/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Email.ts
‚îÇ   ‚îî‚îÄ‚îÄ repositories/
‚îÇ       ‚îî‚îÄ‚îÄ IUserRepository.ts # Interface (sin implementaci√≥n)
‚îÇ
‚îú‚îÄ‚îÄ application/                # Casos de uso / servicios de aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ useCases/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RegisterUser.ts
‚îÇ   ‚îî‚îÄ‚îÄ services/              # Coordinaci√≥n entre entidades y l√≥gica
‚îÇ       ‚îî‚îÄ‚îÄ HashPassword.ts
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/             # Todo lo que depende de tecnolog√≠a externa
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prisma/            # ORM espec√≠fico
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PrismaClient.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserRepository.ts  # Implementa IUserRepository
‚îÇ   ‚îú‚îÄ‚îÄ http/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userRoutes.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ UserController.ts
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ jwt.ts
‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ       ‚îî‚îÄ‚îÄ env.ts
‚îÇ
‚îú‚îÄ‚îÄ interfaces/              # Interfaces externas como controladores, middlewares
‚îÇ   ‚îú‚îÄ‚îÄ http/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authMiddleware.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ server.ts
‚îÇ
‚îú‚îÄ‚îÄ shared/                     # Utilidades compartidas
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îî‚îÄ‚îÄ logger.ts
‚îÇ
‚îî‚îÄ‚îÄ index.ts                    # Punto de entrada (arranca el servidor)

```

### ‚úîÔ∏è Cuando usar Clean Arquitecture?

Clean arquitecture es mas usada en **Backend**, pero tambien se puede aplicar en el front (para el front, personalmente prefiero featured-based design para proyectos medianos-grandes, y para proyectos muy grandes, featured-based + atomic design)

| Criterio / Necesidad                                             | MVC | Clean Architecture | Hexagonal Architecture |     |
| ---------------------------------------------------------------- | --- | ------------------ | ---------------------- | --- |
| Proyecto peque√±o o prototipo r√°pido                              | ‚òëÔ∏è  | ‚òê                  | ‚òê                      |     |
| Aplicaci√≥n CRUD simple con una sola fuente de entrada (HTTP)     | ‚òëÔ∏è  | ‚òê                  | ‚òê                      |     |
| Reglas de negocio sencillas                                      | ‚òëÔ∏è  | ‚òê                  | ‚òê                      |     |
| Necesitas crecer el proyecto en el futuro                        | ‚òê   | ‚òëÔ∏è                 | ‚òëÔ∏è                     |     |
| Requiere alta testabilidad                                       | ‚òê   | ‚òëÔ∏è                 | ‚òëÔ∏è                     |     |
| Interacci√≥n con m√∫ltiples interfaces (API, CLI, cola de eventos) | ‚òê   | ‚òëÔ∏è                 | ‚òëÔ∏è                     |     |
| Separaci√≥n clara entre negocio y tecnolog√≠a                      | ‚òê   | ‚òëÔ∏è                 | ‚òëÔ∏è                     |     |
| Probabilidad de migrar base de datos o framework                 | ‚òê   | ‚òëÔ∏è                 | ‚òëÔ∏è                     |     |
| Necesitas aplicar DDD (Domain-Driven Design)                     | ‚òê   | ‚òëÔ∏è                 | ‚òëÔ∏è                     |     |
| Equipo grande / m√∫ltiples equipos trabajando en capas distintas  | ‚òê   | ‚òëÔ∏è                 | ‚òëÔ∏è                     |     |
| Prefieres reglas expl√≠citas y estructura m√°s r√≠gida              | ‚òê   | ‚òëÔ∏è                 | ‚òê                      |     |
| Prefieres flexibilidad con entradas y salidas (ports/adapters)   | ‚òê   | ‚òê                  | ‚òëÔ∏è                     |     |
| Aplicaci√≥n orientada a eventos o microservicios                  | ‚òê   | ‚òëÔ∏è                 | ‚òëÔ∏è                     |     |

- ‚úÖ Usa **MVC** si: es un proyecto peque√±o, r√°pido, con l√≥gica sencilla, y solo una interfaz.
    
- ‚úÖ Usa **Clean Architecture** si: necesitas escalar, testear bien, cambiar tecnolog√≠a, o tienes l√≥gica de negocio seria.
    
- ‚úÖ Usa **Hexagonal** si: vas a interactuar con m√∫ltiples sistemas y necesitas m√°xima independencia de entrada/salida.