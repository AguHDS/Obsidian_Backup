### **1. Encapsulamiento avanzado**

- Inmutabilidad
    
- Clases anidadas (inner classes)
    
- Acceso a atributos privados a través de métodos
    

---

### **2. Herencia avanzada**

- Herencia múltiple (por interfaces)
    
- Problemas de herencia (como el “diamond problem”)
    
- Composición vs Herencia (muy importante)
    

---

### **3. Polimorfismo**

- Polimorfismo en tiempo de compilación vs ejecución
    
- Sobrecarga de métodos (`method overloading`)
    
- Sobreescritura de métodos (`method overriding`)
    
- Uso real de polimorfismo con clases abstractas e interfaces
    

---

### **4. Abstracción**

- Clases abstractas vs interfaces
    
- Contratos y diseño por contrato
    
- Beneficios reales de la abstracción
    

---

### **5. Principios SOLID (clave para diseño orientado a objetos)**

- Single Responsibility Principle
    
- Open/Closed Principle
    
- Liskov Substitution Principle
    
- Interface Segregation Principle
    
- Dependency Inversion Principle
    

---

### **6. Patrones de diseño orientados a objetos**

- Singleton
    
- Factory / Abstract Factory
    
- Strategy
    
- Observer
    
- Decorator
    
- Adapter
    

> Puedes hacer una carpeta separada para estos con ejemplos.

---

### **7. Relaciones entre clases**

- Asociación, agregación y composición (diferencias con ejemplos)
    
- Diagramas de clases UML básicos
    

---

### **8. Manejo de errores en POO**

- Excepciones personalizadas
    
- Buenas prácticas en encapsulamiento de errores
    

---

### **9. Buenas prácticas y antipatrones en POO**

- Código acoplado vs desacoplado
    
- Ley de Demeter
    
- DRY (Don't Repeat Yourself) y KISS
    

---

### **10. Aplicación práctica**

- Refactorización orientada a objetos
    
- Testing de clases orientadas a objetos (mocks, stubs, etc.)
    
- POO en arquitecturas modernas (MVC, DDD)